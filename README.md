# Authorization JWT Demo

Demo project with 2 servers to test JWT authorization methods, perfect to get started with creating auth APIs. This project skips authentication, check other demo repo for this on my organization. 

## Table of Contents

- [Authorization JWT Demo](#authorization-jwt-demo)
  - [Architecture and Setup](#architecture-and-setup)
    - [Tech Stack](#tech-stack)
    - [Creating JWT Secret](#creating-jwt-secret)
    - [Running the Servers](#running-the-servers)
    - [Testing the Servers](#testing-the-servers)
  - [Considerations for Production](#considerations-for-production)
  - [Security Considerations](#security-considerations-for-jwt-management)

## Architecture and Setup

### Tech Stack

- Node.js
- Express API
- Nodemon
- jsonwebtoken (JWT)

### Creating JWT Secret

Create a `.env` file, and run the following command to generate JWT secrets:

```bash
node
require('crypto').randomBytes(64).toString('hex')
```

Save the results inside the `.env` file and make sure to run it twice:

```bash
JWT_SECRET = output1
REFRESH_JWT_SECRET = output2
```

### Running the Servers

Start the dev server that exposes the contents:
```bash
npm run dev
```

Start the auth server:
```bash
npm run auth
```

### Testing the Servers

Open the file [requests.rest](./requests.rest) and run the following endpoints:

#### 1. Login

```bash
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"username": "jhon"}' \
  'http://localhost:4000/login'
```

Copy the access token and the refresh token. The refresh token will be used to refresh access tokens and to log out, it never expires on this demo.

#### 2. Get User Posts

```bash
curl -X GET \
  -H "Authorization: Bearer access_token" \
  'http://localhost:3000/user/posts'
```

Try sending this same request until you get a forbidden 403 error. At that point, you will need to refresh the access token.

#### 3. Refresh Token

```bash
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"refreshToken": "refresh_token"}' \
  'http://localhost:4000/refresh/token'
```

This will return a new access token that you can use to continue testing.

#### 4. Verify New Token Works

Test a GET endpoint just like in step 2 to verify that the new token works.

#### 5. Logout

```bash
curl -X DELETE \
  -H "Content-Type: application/json" \
  -d '{"refreshToken": "refresh_token"}' \
  'http://localhost:4000/logout'
```

#### 6. Test Token After Logout

Try refreshing the token - you should get a 403 forbidden error as the refresh token no longer exists.

#### 7. Test Expired Access Token

Test the last access token you had. It should work until it expires. Check the duration in [authServer.js](./authServer.js) and adjust accordingly to test comfortably.

## Considerations for Production

- Add a field that indicates if the token was generated by a refresh or not to the payload. This is useful for critical operations like deleting an account or processing payments. This way, the user will need to log in again for sensitive operations if using a refreshed token.

- This demo doesn't include a register endpoint as it would require a database for proper implementation.

- The access token remains valid after logout until it expires. In a production environment, this creates a security vulnerability.

## Security Considerations for JWT Management

The current implementation has a security vulnerability: after logout, access tokens remain valid until they expire. This creates a potential security risk where unauthorized access could occur. Here are strategies to mitigate this issue:

1. **Token blacklisting**: Implement a token blacklist (using Redis or similar) to store invalid tokens until expiration. Every request would check against this blacklist.

2. **Client-side token removal**: Ensure tokens are removed from localStorage, sessionStorage or cookies during logout.

3. **Shorter token lifetimes**: Reduce access token expiration times to minimize the vulnerability window.

4. **Stateful verification**: Store a token version or timestamp in the user record that must match the token.

5. **Sliding sessions**: Issue new tokens with each request and invalidate previous ones.

6. **One-time use tokens**: For highly sensitive operations, implement single-use tokens that become invalid after a request.

7. **Implement CSRF protection**: Use CSRF tokens alongside JWTs for additional security.

Most production systems use a combination of these approaches based on their security requirements.